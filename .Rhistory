return(PlanCost)
}
#We calculate the expected cost per renewal/ expected length of renewal
ExpectedCost=Omega
ExpectedLength=0
for(parameter in 1:ncol(CostToProgressMatrix))
{
WaitFor=WaitingPlan[1,parameter]
for(time in 1:(WaitFor+1))
{
ExpectedCost=ExpectedCost+(CostToProgressMatrix[time,parameter]*ParameterPMF[parameter])
}
ExpectedLength=ExpectedLength+((WaitFor+1)*ParameterPMF[parameter])
}
PlanCost=ExpectedCost/ExpectedLength
return(PlanCost)
}
IterationOfEquilibriumCost<-function(Omega,CostToProgressMatrix,ParameterPMF,MaxNumberOfIterations,MinTolerance,InitialEquilibriumGuess=NULL,gBoundValueMatrix=NULL)
{
if(is.null(InitialEquilibriumGuess))
{
InitialEquilibriumGuess=min(CostToProgressMatrix[nrow(CostToProgressMatrix),])
}
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
print(gBoundValueMatrix)
#Perform iteration of g starting with initial guess
IterationNumber=1
Tolerance=MinTolerance+1
EquilibriumGuess=InitialEquilibriumGuess
while(IterationNumber<=MaxNumberOfIterations && Tolerance>MinTolerance)
{
#For the current guess find the plan
Plan=PlanFinder(EquilibriumGuess,CostToProgressMatrix,gBoundValueMatrix)
print(Plan)
#Find the Equilibrium cost generated by this plan
PlanCost=PlanCost(Omega,Plan$WaitingPlan,CostToProgressMatrix,ParameterPMF)
OldEquilibriumGuess=EquilibriumGuess
EquilibriumGuess=PlanCost
print(PlanCost)
IterationNumber=IterationNumber+1
Tolerance=abs(EquilibriumGuess-OldEquilibriumGuess)/OldEquilibriumGuess
}
return(list(IterationsTaken=IterationNumber,EquilibriumGuess=EquilibriumGuess,Plan=Plan))
}
IterationOfEquilibriumCost(5,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(2,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(5,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
GenerateAverages<-function(CostToProgressMatrix)
{
SumAveragesMatrix=matrix(list(),nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
GValueMatrix=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SumAveragesMatrix))
{
for(parameter in 1:ncol(SumAveragesMatrix))
{
#For (s,v) we need to calculate all possible average and store them in a vector to be then placed in the matrix
StateChoiceVector=vector(length=(nrow(CostToProgressMatrix)-time+1))
for(i in 1:length(StateChoiceVector))
{
if(i==1)
{
StateChoiceVector[i]=CostToProgressMatrix[time,parameter]
}
else
{
StateChoiceVector[i]=((i-1)*StateChoiceVector[i-1]+CostToProgressMatrix[time+(i-1),parameter])/i
}
SumAveragesMatrix[[time,parameter]]=StateChoiceVector
GValueMatrix[time,parameter]=min(StateChoiceVector)
}
}
}
return(list(AveragesMatrix=SumAveragesMatrix,gBoundValueMatrix=GValueMatrix))
}
PlanFinder<-function(gValue,CostToProgressMatrix,gBoundValueMatrix=NULL)
{
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
SimplePlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SimplePlan))
{
for(parameter in 1:ncol(SimplePlan))
{
if(gValue<=gBoundValueMatrix[time,parameter])
{
#We renew in this case
SimplePlan[time,parameter]=0
}
else
{
SimplePlan[time,parameter]=1
}
}
}
#Convert simple plan into waiting plan
WaitingPlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in nrow(WaitingPlan):1)
{
for(parameter in 1:ncol(WaitingPlan))
{
if(SimplePlan[time,parameter]==1)
{
if(time==nrow(WaitingPlan))
{
WaitingPlan[time,parameter]=1
}
else
{
WaitingPlan[time,parameter]=WaitingPlan[time+1,parameter]+1
}
}
else
{
WaitingPlan[time,parameter]=0
}
}
}
return(list(SimplePlan=SimplePlan,WaitingPlan=WaitingPlan))
}
PlanCost<-function(Omega,WaitingPlan,CostToProgressMatrix,ParameterPMF)
{
#First see if we have an infinite waitingPlan
InfiniteParameter=vector(length=0)
for(parameter in 1:ncol(WaitingPlan))
{
if(WaitingPlan[1,parameter]==nrow(WaitingPlan))
{
#This is an infinite recursion plan
InfiniteParameter=c(InfiniteParameter,parameter)
}
}
if(length(InfiniteParameter)!=0)
{
#Work out marginalPMF
MarginalParameterPMF=vector(length=length(InfiniteParameter))
for(i in 1:length(MarginalParameterPMF))
{
MarginalParameterPMF[i]=ParameterPMF[i]
}
MarginalParameterPMF=MarginalParameterPMF/sum(MarginalParameterPMF)
#Set the Plans cost to be the expected cost
InfiniteCost=0
for(i in 1:length(InfiniteParameter))
{
InfiniteCost=InfiniteCost+(CostToProgressMatrix[nrow(CostToProgressMatrix),InfiniteParameter[i]]*MarginalParameterPMF[i])
}
PlanCost=InfiniteCost
return(PlanCost)
}
#We calculate the expected cost per renewal/ expected length of renewal
ExpectedCost=Omega
ExpectedLength=0
for(parameter in 1:ncol(CostToProgressMatrix))
{
WaitFor=WaitingPlan[1,parameter]
for(time in 1:(WaitFor+1))
{
ExpectedCost=ExpectedCost+(CostToProgressMatrix[time,parameter]*ParameterPMF[parameter])
}
ExpectedLength=ExpectedLength+((WaitFor+1)*ParameterPMF[parameter])
}
PlanCost=ExpectedCost/ExpectedLength
return(PlanCost)
}
IterationOfEquilibriumCost<-function(Omega,CostToProgressMatrix,ParameterPMF,MaxNumberOfIterations,MinTolerance,InitialEquilibriumGuess=NULL,gBoundValueMatrix=NULL)
{
if(is.null(InitialEquilibriumGuess))
{
InitialEquilibriumGuess=min(CostToProgressMatrix[nrow(CostToProgressMatrix),])
}
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
print(gBoundValueMatrix)
#Perform iteration of g starting with initial guess
IterationNumber=1
Tolerance=MinTolerance+1
EquilibriumGuess=InitialEquilibriumGuess
while(IterationNumber<=MaxNumberOfIterations && Tolerance>MinTolerance)
{
#For the current guess find the plan
Plan=PlanFinder(EquilibriumGuess,CostToProgressMatrix,gBoundValueMatrix)
print(Plan)
#Find the Equilibrium cost generated by this plan
PlanCost=PlanCost(Omega,Plan$WaitingPlan,CostToProgressMatrix,ParameterPMF)
OldEquilibriumGuess=EquilibriumGuess
EquilibriumGuess=PlanCost
print(PlanCost)
IterationNumber=IterationNumber+1
Tolerance=abs(EquilibriumGuess-OldEquilibriumGuess)/OldEquilibriumGuess
}
return(list(IterationsTaken=IterationNumber,EquilibriumGuess=EquilibriumGuess,Plan=Plan))
}
IterationOfEquilibriumCost(5,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
GenerateAverages<-function(CostToProgressMatrix)
{
SumAveragesMatrix=matrix(list(),nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
GValueMatrix=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SumAveragesMatrix))
{
for(parameter in 1:ncol(SumAveragesMatrix))
{
#For (s,v) we need to calculate all possible average and store them in a vector to be then placed in the matrix
StateChoiceVector=vector(length=(nrow(CostToProgressMatrix)-time+1))
for(i in 1:length(StateChoiceVector))
{
if(i==1)
{
StateChoiceVector[i]=CostToProgressMatrix[time,parameter]
}
else
{
StateChoiceVector[i]=((i-1)*StateChoiceVector[i-1]+CostToProgressMatrix[time+(i-1),parameter])/i
}
SumAveragesMatrix[[time,parameter]]=StateChoiceVector
GValueMatrix[time,parameter]=min(StateChoiceVector)
}
}
}
return(list(AveragesMatrix=SumAveragesMatrix,gBoundValueMatrix=GValueMatrix))
}
PlanFinder<-function(gValue,CostToProgressMatrix,gBoundValueMatrix=NULL)
{
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
SimplePlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SimplePlan))
{
for(parameter in 1:ncol(SimplePlan))
{
print(gValue)
print(gBoundValueMatrix[time,parameter])
if(gValue<=gBoundValueMatrix[time,parameter])
{
#We renew in this case
SimplePlan[time,parameter]=0
}
else
{
SimplePlan[time,parameter]=1
}
}
}
#Convert simple plan into waiting plan
WaitingPlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in nrow(WaitingPlan):1)
{
for(parameter in 1:ncol(WaitingPlan))
{
if(SimplePlan[time,parameter]==1)
{
if(time==nrow(WaitingPlan))
{
WaitingPlan[time,parameter]=1
}
else
{
WaitingPlan[time,parameter]=WaitingPlan[time+1,parameter]+1
}
}
else
{
WaitingPlan[time,parameter]=0
}
}
}
return(list(SimplePlan=SimplePlan,WaitingPlan=WaitingPlan))
}
PlanCost<-function(Omega,WaitingPlan,CostToProgressMatrix,ParameterPMF)
{
#First see if we have an infinite waitingPlan
InfiniteParameter=vector(length=0)
for(parameter in 1:ncol(WaitingPlan))
{
if(WaitingPlan[1,parameter]==nrow(WaitingPlan))
{
#This is an infinite recursion plan
InfiniteParameter=c(InfiniteParameter,parameter)
}
}
if(length(InfiniteParameter)!=0)
{
#Work out marginalPMF
MarginalParameterPMF=vector(length=length(InfiniteParameter))
for(i in 1:length(MarginalParameterPMF))
{
MarginalParameterPMF[i]=ParameterPMF[i]
}
MarginalParameterPMF=MarginalParameterPMF/sum(MarginalParameterPMF)
#Set the Plans cost to be the expected cost
InfiniteCost=0
for(i in 1:length(InfiniteParameter))
{
InfiniteCost=InfiniteCost+(CostToProgressMatrix[nrow(CostToProgressMatrix),InfiniteParameter[i]]*MarginalParameterPMF[i])
}
PlanCost=InfiniteCost
return(PlanCost)
}
#We calculate the expected cost per renewal/ expected length of renewal
ExpectedCost=Omega
ExpectedLength=0
for(parameter in 1:ncol(CostToProgressMatrix))
{
WaitFor=WaitingPlan[1,parameter]
for(time in 1:(WaitFor+1))
{
ExpectedCost=ExpectedCost+(CostToProgressMatrix[time,parameter]*ParameterPMF[parameter])
}
ExpectedLength=ExpectedLength+((WaitFor+1)*ParameterPMF[parameter])
}
PlanCost=ExpectedCost/ExpectedLength
return(PlanCost)
}
IterationOfEquilibriumCost<-function(Omega,CostToProgressMatrix,ParameterPMF,MaxNumberOfIterations,MinTolerance,InitialEquilibriumGuess=NULL,gBoundValueMatrix=NULL)
{
if(is.null(InitialEquilibriumGuess))
{
InitialEquilibriumGuess=min(CostToProgressMatrix[nrow(CostToProgressMatrix),])
}
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
print(gBoundValueMatrix)
#Perform iteration of g starting with initial guess
IterationNumber=1
Tolerance=MinTolerance+1
EquilibriumGuess=InitialEquilibriumGuess
while(IterationNumber<=MaxNumberOfIterations && Tolerance>MinTolerance)
{
#For the current guess find the plan
Plan=PlanFinder(EquilibriumGuess,CostToProgressMatrix,gBoundValueMatrix)
print(Plan)
#Find the Equilibrium cost generated by this plan
PlanCost=PlanCost(Omega,Plan$WaitingPlan,CostToProgressMatrix,ParameterPMF)
OldEquilibriumGuess=EquilibriumGuess
EquilibriumGuess=PlanCost
print(PlanCost)
IterationNumber=IterationNumber+1
Tolerance=abs(EquilibriumGuess-OldEquilibriumGuess)/OldEquilibriumGuess
}
return(list(IterationsTaken=IterationNumber,EquilibriumGuess=EquilibriumGuess,Plan=Plan))
}
IterationOfEquilibriumCost(5,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
GenerateAverages<-function(CostToProgressMatrix)
{
SumAveragesMatrix=matrix(list(),nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
GValueMatrix=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SumAveragesMatrix))
{
for(parameter in 1:ncol(SumAveragesMatrix))
{
#For (s,v) we need to calculate all possible average and store them in a vector to be then placed in the matrix
StateChoiceVector=vector(length=(nrow(CostToProgressMatrix)-time+1))
for(i in 1:length(StateChoiceVector))
{
if(i==1)
{
StateChoiceVector[i]=CostToProgressMatrix[time,parameter]
}
else
{
StateChoiceVector[i]=((i-1)*StateChoiceVector[i-1]+CostToProgressMatrix[time+(i-1),parameter])/i
}
SumAveragesMatrix[[time,parameter]]=StateChoiceVector
GValueMatrix[time,parameter]=min(StateChoiceVector)
}
}
}
return(list(AveragesMatrix=SumAveragesMatrix,gBoundValueMatrix=GValueMatrix))
}
PlanFinder<-function(gValue,CostToProgressMatrix,gBoundValueMatrix=NULL)
{
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
SimplePlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in 1:nrow(SimplePlan))
{
for(parameter in 1:ncol(SimplePlan))
{
print(gValue)
print(gBoundValueMatrix[time,parameter])
if(gValue<=gBoundValueMatrix[time,parameter])
{
#We renew in this case
print("Renew now")
SimplePlan[time,parameter]=0
}
else
{
SimplePlan[time,parameter]=1
}
}
}
#Convert simple plan into waiting plan
WaitingPlan=matrix(nrow=nrow(CostToProgressMatrix),ncol=ncol(CostToProgressMatrix))
for(time in nrow(WaitingPlan):1)
{
for(parameter in 1:ncol(WaitingPlan))
{
if(SimplePlan[time,parameter]==1)
{
if(time==nrow(WaitingPlan))
{
WaitingPlan[time,parameter]=1
}
else
{
WaitingPlan[time,parameter]=WaitingPlan[time+1,parameter]+1
}
}
else
{
WaitingPlan[time,parameter]=0
}
}
}
return(list(SimplePlan=SimplePlan,WaitingPlan=WaitingPlan))
}
PlanCost<-function(Omega,WaitingPlan,CostToProgressMatrix,ParameterPMF)
{
#First see if we have an infinite waitingPlan
InfiniteParameter=vector(length=0)
for(parameter in 1:ncol(WaitingPlan))
{
if(WaitingPlan[1,parameter]==nrow(WaitingPlan))
{
#This is an infinite recursion plan
InfiniteParameter=c(InfiniteParameter,parameter)
}
}
if(length(InfiniteParameter)!=0)
{
#Work out marginalPMF
MarginalParameterPMF=vector(length=length(InfiniteParameter))
for(i in 1:length(MarginalParameterPMF))
{
MarginalParameterPMF[i]=ParameterPMF[i]
}
MarginalParameterPMF=MarginalParameterPMF/sum(MarginalParameterPMF)
#Set the Plans cost to be the expected cost
InfiniteCost=0
for(i in 1:length(InfiniteParameter))
{
InfiniteCost=InfiniteCost+(CostToProgressMatrix[nrow(CostToProgressMatrix),InfiniteParameter[i]]*MarginalParameterPMF[i])
}
PlanCost=InfiniteCost
return(PlanCost)
}
#We calculate the expected cost per renewal/ expected length of renewal
ExpectedCost=Omega
ExpectedLength=0
for(parameter in 1:ncol(CostToProgressMatrix))
{
WaitFor=WaitingPlan[1,parameter]
for(time in 1:(WaitFor+1))
{
ExpectedCost=ExpectedCost+(CostToProgressMatrix[time,parameter]*ParameterPMF[parameter])
}
ExpectedLength=ExpectedLength+((WaitFor+1)*ParameterPMF[parameter])
}
PlanCost=ExpectedCost/ExpectedLength
return(PlanCost)
}
IterationOfEquilibriumCost<-function(Omega,CostToProgressMatrix,ParameterPMF,MaxNumberOfIterations,MinTolerance,InitialEquilibriumGuess=NULL,gBoundValueMatrix=NULL)
{
if(is.null(InitialEquilibriumGuess))
{
InitialEquilibriumGuess=min(CostToProgressMatrix[nrow(CostToProgressMatrix),])
}
if(is.null(gBoundValueMatrix))
{
gBoundValueMatrix=GenerateAverages(CostToProgressMatrix)$gBoundValueMatrix
}
print(gBoundValueMatrix)
#Perform iteration of g starting with initial guess
IterationNumber=1
Tolerance=MinTolerance+1
EquilibriumGuess=InitialEquilibriumGuess
while(IterationNumber<=MaxNumberOfIterations && Tolerance>MinTolerance)
{
#For the current guess find the plan
Plan=PlanFinder(EquilibriumGuess,CostToProgressMatrix,gBoundValueMatrix)
print(Plan)
#Find the Equilibrium cost generated by this plan
PlanCost=PlanCost(Omega,Plan$WaitingPlan,CostToProgressMatrix,ParameterPMF)
OldEquilibriumGuess=EquilibriumGuess
EquilibriumGuess=PlanCost
print(PlanCost)
IterationNumber=IterationNumber+1
Tolerance=abs(EquilibriumGuess-OldEquilibriumGuess)/OldEquilibriumGuess
}
return(list(IterationsTaken=IterationNumber,EquilibriumGuess=EquilibriumGuess,Plan=Plan))
}
IterationOfEquilibriumCost(5,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(2,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(1,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(3,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(2.6,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(2.1,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
IterationOfEquilibriumCost(1,matrix(c(1,2,1,4,3,5,5,10,2,10),nrow=5,ncol=2),c(0.5,0.5),10,0.001)
